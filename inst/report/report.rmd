---
title: "Omics datasets evaluation report" 
date: "`r Sys.Date()`"

output:
  BiocStyle::html_document:
    toc_float: true
params:
  input: ""

vignette: >
  %\VignetteIndexEntry{OmicsEV report}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteKeywords{Mass Spectrometry, Proteomics, omics, eveluation }
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
library(OmicsEV)
library(knitr)
library(png)
library(kableExtra)
library(formattable)
#library(DT)
knitr::opts_chunk$set(echo = FALSE)

```

```{r Import data, echo=FALSE}
final_res <- readRDS(params$input)
basic_metrics <- final_res$basic_metrics
network_table <- final_res$network_table
protein_rna <- final_res$protein_rna
```


# Introduction

In this evaluation, there are total **`r final_res$input_parameters$n_datasets`** datasets. We used the evaluation metrics implemented in **OmicsEV** package to evaluate these datasets. The sample and class information for each dataset are shown in the table below.

```{r echo=FALSE}
class_samples_table <- get_sample_data(final_res$input_parameters$datasets)
kable(class_samples_table, "html") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
    
```

The detailed sample information is shown below.

```{r echo=FALSE}
kable(final_res$input_parameters$sample_list, "html") %>%
  kable_styling(bootstrap_options = "striped", full_width = F) %>%
  scroll_box(height = "400px",width = "100%")
   
```


```{r Seperate, echo=FALSE}
n_batch <- final_res$input_parameters$sample_list$batch %>% unique() %>% length
dataset_names <- names(basic_metrics$datasets)

```

# Overview

```{r echo=FALSE}
#save(final_res,file="a.rda")
ov_table_list <- generate_overview_table(final_res)
ov_table <- ov_table_list$dat
kable(format_overview_table(ov_table_list), "html",digits = 4,escape = FALSE) %>%
      kable_styling(bootstrap_options = "striped", full_width = F) %>%
      scroll_box(height = "400px",width = "100%")
```

```{r echo=FALSE, fig.align='center', warning=FALSE,message=FALSE}
#save(final_res,file="a.rda")
if(ncol(ov_table) > 3){
    if("#identified features" %in% names(ov_table) && "#quantifiable features" %in% names(ov_table)){
        # no process
        ov_data <- ov_table
    }else{
        ov_data <- ov_table[,-c(2,3)]
    }
    
  plot_radar(ov_data)
}
```



# Data depth

## Study-wise

The table below shows the number of identified proteins or genes for each dataset. We take the proteins or genes filtered by 50% missing value as quantified proteins or genes.

```{r echo=FALSE}
#save(final_res,file="a.rda")
id_table <- get_identification_summary_table(final_res) %>% dplyr::rename(`data table`=dataSet)
kable(id_table,"html",escape = FALSE) %>%
  kable_styling(bootstrap_options = "striped", full_width = F) #%>%
    #row_spec(which.max(id_table[,3]), bold = T, color = "red")
```

```{r results="asis"}
if(!is.null(final_res$basic_metrics$datasets_id_overla)){
  cat("Upset chart below showing overlap in proteins or genes identified in each dataset. Numbers of identified proteins or genes shared between different datasets are indicated in the top bar chart and the specific datasets in each set are indicated with solid points below the bar chart. Total identifications for each dataset are indicated on the left as ‘Set size’.\n")
  knitr::include_graphics(final_res$basic_metrics$datasets_id_overlap %>% normalizePath)
}
```


## Sample-wise

The figures below show the number of proteins or genes identified in each sample. The samples from different batches are coded in different shapes and the samples from different classes are coded in different colors.

```{r, echo=FALSE, fig.align='center', results='asis'}
figs <- get_metrics(final_res$basic_metrics$datasets, metric = "features_number_distribution")
figs <- get_full_path(figs)
for(i in 1:length(figs)){
  knitr::include_graphics(figs[i] %>% normalizePath)
  cat(names(figs)[i])
  cat("![](",figs[i],")")
}
```

## Missing value distribution

The missing value distribution can give an overview of the percent of missing values of all proteins or genes in both the QC and experiment samples.


```{r echo=FALSE}
missing_value_table <- lapply(final_res$basic_metrics$datasets,function(y)y[["non_missing_value_ratio"]]) %>% 
    dplyr::bind_rows() %>% 
    dplyr::rename(non_missing_value_ratio=ratio) %>%
    dplyr::rename(`data table`=dataSet)
kable(missing_value_table,"html",escape = FALSE, digits = 4) %>%
  kable_styling(bootstrap_options = "striped", full_width = F) %>%
    row_spec(which.max(missing_value_table$non_missing_value_ratio), bold = T, color = "red")
```


```{r, echo=FALSE, fig.align='center', results='asis'}
figs <- get_metrics(final_res$basic_metrics$datasets, metric = "missing_value_distribution")
figs <- get_full_path(figs)
for(i in 1:length(figs)){
  knitr::include_graphics(figs[i] %>% normalizePath)
  cat(names(figs)[i])
  cat("![](",figs[i],")")
}
```

# Data normalization

## Boxplot

The boxplots show the protein or gene expression distribution across samples. X axis is sample ordered by input order. Y axis is log2 transformed protein or gene expression. The samples from different classes are coded in different colors.

```{r echo=FALSE}
if("quant_median_ks" %in% names(final_res$basic_metrics)){
    kable(final_res$basic_metrics$quant_median_ks %>%
              dplyr::rename(data_dist_similarity=raw_quant_median_ks) %>%
              dplyr::rename(`data table`=dataSet) %>%
              dplyr::select(-quant_median_ks),#scaled_data_dist_similarity=quant_median_ks)
                     "html",escape = FALSE, digits = 4) %>%
        kable_styling(bootstrap_options = "striped", full_width = F) %>%
        row_spec(which.min(final_res$basic_metrics$quant_median_ks$raw_quant_median_ks), bold = T, color = "red")
}
```


```{r, echo=FALSE, fig.align='center', results='asis'}
figs <- get_metrics(final_res$basic_metrics$datasets, metric = "features_quant_distribution")
figs <- get_full_path(figs)
for(i in 1:length(figs)){
  knitr::include_graphics(figs[i] %>% normalizePath)
  cat(names(figs)[i])
  cat("![](",figs[i],")")
}

```

## Density plot

The density plots show the protein or gene expression distribution across samples. X axis is log2 transformed protein or gene expression. Y axis is density.

```{r, echo=FALSE, fig.align='center', results='asis'}
knitr::include_graphics(final_res$basic_metrics$density_plot %>% normalizePath)
```





# Batch effect


```{r results="asis",fig.align='center'}
if(n_batch >= 2){
  if(!is.null(final_res$batch_effect_metrics$kbet)){
    cat("## Batch effect evaluation using kBET\n\n")
    cat("<p>In this section, we used k-nearest neighbour batch effect test (kBET) for quantification of batch effects. First, the algorithm creates k-nearest neighbour matrix and choses 10% of the samples to check the batch label distribution in its neighbourhood. If the local batch label distribution is sufficiently similar to the global batch label distribution, the $\\chi^2$-test does not reject the null hypothesis (that is 'all batches are well-mixed'). Finally, the result of kBET is the average test rejection rate. The lower the test result, the less bias is introduced by the batch effect.</p>\n")
    kbet_res <- final_res$batch_effect_metrics$kbet
    kable(kbet_res$table, "html",digits = 4,escape = FALSE) %>%
    kable_styling(bootstrap_options = "striped", full_width = F)
  }
}
```


```{r results="asis",fig.align='center'}
if(n_batch >= 2){  
  cat("## Silhouette width\n\n")
  cat("<p>The silhouette width s(i) ranges from –1 to 1, with s(i) -> 1 if two clusters
are separate and s(i) -> −1 if two clusters overlap but have dissimilar variance.
If s(i) -> 0, both clusters have roughly the same structure. Thus, we use the
absolute value |s| as an indicator for the presence or absence of batch effects.</p>\n")
  sil_res <- final_res$batch_effect_metrics$sil
  show_sil <- data.frame(dataSet=names(sil_res),silhouette_width=sil_res) %>%
      dplyr::rename(`data table`=dataSet)
  rownames(show_sil) <- NULL
  kable(show_sil, "html",digits = 4,escape = FALSE) %>%
      kable_styling(bootstrap_options = "striped", full_width = F) %>%
      row_spec(which.min(abs(show_sil$silhouette_width)), bold = T, color = "red")
}
```


```{r results="asis",fig.align='center'}
if(n_batch >= 2){
  cat("## PCA with batch annotation\n\n")
  cat("<p>For each PC, we calculate Pearson's correlation coefficient with batch covariate b:</p>\n")
  cat("<p style='text-align: center;'>r<sub>i</sub> =corr(PC<sub>i</sub>,b)</p>\n")
  cat("<p>In a linear model with a single dependent, as is the case here for the PCs correlated to batch covariate, the coefficient of determination R<sup>2</sup> is the squared Pearson's correlation coefficient:</p>\n")
  cat("<p style='text-align: center;'>R<sup>2</sup>(PC<sub>i</sub>,b) = r<sub>i</sub><sup>2</sup></p>\n")
  cat("<p>Then we estimate the significance of the correlation coefficient either with a t-test or a one-way ANOVA. The R<sup>2</sup> value highlighted with red is significant (p-value <= 0.05).</p>\n")
  pcr_res <- final_res$batch_effect_metrics$pcr
  kable(pcr_res$table, "html",digits = 4,escape = FALSE) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
  
}
```

```{r results="asis",fig.align='center'}
if(n_batch >= 2){
  cat("<p>The fraction of variance explained for each PC:</p>\n")
  kable(pcr_res$explained_var, "html",escape = FALSE) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
  }
```

```{r results="asis",fig.align='center'}
if(n_batch >= 2){
  cat("<p>'Scaled PC regression', i.e. total variance of PCs which correlate significantly with batch covariate (FDR<0.05) scaled by the total variance of",pcr_res$top_pc,"PCs:</p>\n")
  kable(pcr_res$pcRegscale %>% dplyr::rename(`data table`=dataSet), "html",escape = FALSE) %>%
      kable_styling(bootstrap_options = "striped", full_width = F) %>%
      row_spec(which.min(pcr_res$pcRegscale$pcRegscale), bold = T, color = "red")
}
```

```{r results="asis",fig.align='center'}
if(n_batch >= 2){
  #cat("## Batch effect evaluation using pca score plot\n\n")
  cat("In these figures, each column is a sample, each row is also a sample. The color indicates the correlation between samples. The samples are ordered by batches.\n")
  fig <- final_res$pca_batch_plot$fig
knitr::include_graphics(fig %>% normalizePath)
  
}
```

```{r results="asis",fig.align='center'}
if(n_batch >= 2){
  if(!is.null(final_res$pca_batch_plot_13)){
    fig <- final_res$pca_batch_plot_13$fig
    knitr::include_graphics(fig %>% normalizePath)
  }
}

```


## Correlation heatmap

In these figures, each column is a sample, each row is also a sample. The color indicates the correlation between samples. The samples are ordered by batches.

```{r, echo=FALSE, fig.align='center', results='asis'}
figs <- get_metrics(final_res$basic_metrics$datasets, metric = "sample_wise_cor_heatmap")
figs <- get_full_path(figs)
for(i in 1:length(figs)){
  knitr::include_graphics(figs[i] %>% normalizePath)
  cat(names(figs)[i])
  cat("![](",figs[i],")")
}

```


# Biological signal


```{r results="asis",fig.align='center'}
if(!is.null(final_res$network_table)){
  cat("## Correlation among protein complex members\n")
  include_graphics(final_res$network_table$network_boxplot %>% normalizePath)
}

```

```{r results="asis",fig.align='center'}
if(!is.null(final_res$network_table)){
  cat("<p>The table showing below is a summary of the evaluation. 'diff' is Cor(intra) - Cor(inter). 'complex_ks' is the statistic value of Kolmogorov-Smirnov test.</p>\n")
  final_res$network_table$cor <- final_res$network_table$cor %>% dplyr::rename(complex_ks=ks)    
  kable(final_res$network_table$cor %>% dplyr::rename(`data table`=dataSet), "html",digits = 4) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)%>%
    row_spec(which.max(final_res$network_table$cor$complex_ks), bold = T, color = "red")
}

```


```{r results="asis",fig.align='center'}

if(!is.null(final_res$fun_pred)){
  cat("## Gene function prediction\n")
  cat("<p>In this evaluation, each dataset was used to build co-expression network. For a selected network and a selected function term (such as GO or KEGG), proteins/genes annotated to the term and also included in the network were defined as a positive protein/gene set and other proteins/genes in the network constituted the negative protein/gene set for the term. For a selected function term, we use some of the proteins/genes as the seed protein/gene, then we use random walk algorithm to calculate scores for other proteins/genes. A higher score of a protein/gene represents a closer relationship between the protein/gene and the seed proteins/genes. Finally, for each selected function term, we calculate an AUROC to evaluate the prediction performance.</p>\n")
  kable(final_res$fun_pred$table, "html",digits = 3,escape = FALSE) %>%
  kable_styling(bootstrap_options = "striped", full_width = F) %>%
  scroll_box(height = "400px",width = "100%")
}

```


```{r, echo=FALSE}
if(!is.null(final_res$fun_pred)){
  if(!is.null(final_res$fun_pred$fig)){
    include_graphics(final_res$fun_pred$fig %>% normalizePath)
  }
}
```

```{r results="asis",fig.align='center'}

if(!is.null(final_res$fun_pred)){
  
  if(!is.null(final_res$fun_pred$two_group_fig)){
    figs <- sapply(final_res$fun_pred$two_group_fig, function(x){x})
    figs <- get_full_path(figs)
    for(i in 1:length(figs)){
      knitr::include_graphics(figs[i] %>% normalizePath)
      cat(names(figs)[i])
      cat("![](",figs[i],")")
    }
  }
}

```


```{r results="asis",fig.align='center'}

if(!is.null(final_res$ml)){
  cat("## Sample class prediction\n")
  cat("<p>Build model for prediction:",paste(final_res$ml$class_group,collapse = ","),".</p>\n")
  kable(final_res$ml$table, "html",digits = 3) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
  
}

```

```{r results="asis",fig.align='center'}

if(!is.null(final_res$ml)){
  
  if(!is.null(final_res$ml$fig)){
    include_graphics(final_res$ml$fig %>% normalizePath)
  }
}

```



## PCA with sample class annotation

```{r, echo=FALSE, fig.align='center', results='asis'}
figs <- get_metrics(final_res$basic_metrics$datasets, metric = "pca_with_batch")
figs <- get_full_path(figs)
for(i in 1:length(figs)){
  knitr::include_graphics(figs[i] %>% normalizePath)
  cat(names(figs)[i])
  cat("![](",figs[i],")")
}
```

## Unsupervised clustering

```{r, echo=FALSE, fig.align='center', results='asis'}
figs <- get_metrics(final_res$basic_metrics$datasets, metric = "cluster_heatmap")
figs <- get_full_path(figs)
for(i in 1:length(figs)){
  knitr::include_graphics(figs[i] %>% normalizePath)
  cat(names(figs)[i])
  cat("![](",figs[i],")")
}

```

```{r results="asis",fig.align='center'}

if(!is.null(final_res$snr)){
  cat("## Noise to signal analysis\n")
  cat("<p>Noise to signal analysis.</p>\n")
  kable(final_res$snr$table, "html",digits = 3) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)%>%
    row_spec(which(final_res$snr$table$nsr <= sort(final_res$snr$table$nsr,decreasing = FALSE)[3]), bold = T, color = "red")
  
}

```

```{r, echo=FALSE}
if(!is.null(final_res$snr)){
  if(!is.null(final_res$snr$fig)){
    include_graphics(final_res$snr$fig %>% normalizePath)
  }
}
```


```{r, echo=FALSE, fig.align='center', results='asis'}

if(!is.null(final_res$snr)){
  figs <- unlist(final_res$snr$mad_figs)
  figs <- get_full_path(figs)
  for(i in 1:length(figs)){
    knitr::include_graphics(figs[i] %>% normalizePath)
    cat(names(figs)[i])
    cat("![](",figs[i],")")
  }
}
```



```{r results="asis",fig.align='center'}
cv_table <- get_cv_table(final_res$basic_metrics$datasets,"cv_stat")
if("QC" %in% cv_table$class){
  cat("# Platform reproducibility\n")
  cat("## Coefficient of variation distribution\n")
  cat("<p>Platform reproducibility is evaluated based on coefficient of variation distribution of QC samples.</p>\n")
  show_cv_table <- cv_table %>% dplyr::filter(class=="QC") %>% dplyr::select(dataSet,class,median_cv)
  kable(show_cv_table %>% dplyr::rename(median_CV=median_cv), "html",digits = 3) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)%>%
    row_spec(which(show_cv_table$median_cv <= sort(show_cv_table$median_cv,decreasing = FALSE)[3]), bold = T, color = "red")
}

```


```{r, echo=FALSE, fig.align='center', results='asis'}

if("QC" %in% cv_table$class){
    figs <- get_metrics(final_res$basic_metrics$datasets, metric = "cv_distribution")
    figs <- get_full_path(figs)
    for(i in 1:length(figs)){
      knitr::include_graphics(figs[i] %>% normalizePath)
      cat(names(figs)[i])
      cat("![](",figs[i],")")
    }
}

```


# Multi-omics concordance

```{r results="asis",fig.align='center'}
if(!is.null(final_res$input_parameters$x2)){
  cat("## Gene-wise mRNA-protein correlation\n")
  kable(final_res$protein_rna$feature_wise_cor_table %>% dplyr::rename(gene_wise_cor=median_cor), "html",digits = 3) %>%
  kable_styling(bootstrap_options = "striped", full_width = F) %>%
    row_spec(which(final_res$protein_rna$feature_wise_cor_table$median_cor >= sort(final_res$protein_rna$feature_wise_cor_table$median_cor,decreasing = TRUE)[3]), bold = T, color = "red")
  
}
```  

```{r results="asis",fig.align='center'}
if(!is.null(final_res$input_parameters$x2)){
  if(!is.null(final_res$protein_rna$gene_wise_cor_boxplot_fig)){
    include_graphics(final_res$protein_rna$gene_wise_cor_boxplot_fig %>% normalizePath)
  }
}
```  

```{r results="asis",fig.align='center'}
if(!is.null(final_res$input_parameters$x2)){
  if(!is.null(final_res$protein_rna$gene_wise_cor_cdf_fig)){
    include_graphics(final_res$protein_rna$gene_wise_cor_cdf_fig %>% normalizePath)
  }
}
```  

```{r, echo=FALSE, fig.align='center', results='asis'}
if(!is.null(final_res$input_parameters$x2)){
  figs <- get_metrics(final_res$protein_rna$data, metric = "hist_fig")
  figs <- get_full_path(figs)
  for(i in 1:length(figs)){
    knitr::include_graphics(figs[i] %>% normalizePath)
    cat(names(figs)[i])
    cat("![](",figs[i],")")
  }
}

```


```{r results="asis",fig.align='center'}
if(!is.null(final_res$input_parameters$x2)){
  cat("## Sample-wise mRNA-protein correlation\n")
  kable(final_res$protein_rna$sample_wise_cor_table %>% dplyr::rename(sample_wise_cor=median_cor), "html",digits = 3) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)%>%
    row_spec(which(final_res$protein_rna$sample_wise_cor_table$median_cor >= sort(final_res$protein_rna$sample_wise_cor_table$median_cor,decreasing = TRUE)[3]), bold = T, color = "red")

}
```

```{r results="asis",fig.align='center'}
if(!is.null(final_res$input_parameters$x2)){
  include_graphics(final_res$protein_rna$sample_wise_cor_fig %>% normalizePath)

}
```







